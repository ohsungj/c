
// 문제 : 원본값을 훼손하는 change 함수를 만들어주세요.(3중포인터)

#include <stdio.h>

void change(int *** num) {
	***num = 50;// k가 가리키는 포인터가 가리키는 값을 50 으로변경
}

int main(void) {
	int x = 20;
	int* p = &x;
	int** k = &p;
	

	printf("change 함수 호출하기 전의 x : %d\n", x);

	change(&k);//포인터 k의값을변경

	printf("change 함수 호출한 후의 x : %d\n", x);
	// 출력 => change 함수 호출한 후의 x : 50

	return 0;
}


// 문제 : 아래 질문에 답해주세요.

/* 힌트
- 변수에는 오직 값이 1개만 들어갈 수 있다.
  - int arr[3]; arr[0] = 100; arr[1] = 200; arr[2] = 300;
    - 여기서 arr에 100과 200과 300이 들어있다는 말은 틀린말입니다.
- 포인터(주소값) 저장하는 변수는 무조건 8바이트 입니다.
- 변수는 공간 1개만 관리합니다.
  - int a = 10; // a는 4바이트를 관리합니다.
  - int b = 20; // b는 4바이트를 관리합니다.
- 변수 1개로 공간 100개 관리하려면?
*/

#include <stdio.h>

// 질문 : sub1 함수는 몇 바이트 짜리 함수 인가요?
// 정답 : 0
// 지역변수가 없으니까
void sub1() {

}

// 질문 : sub2 함수는 몇 바이트 짜리 함수 인가요?
// 8바이트
// 포인터 변수는 타입에 상관없이 무조건 8바이트.
void sub2() {
    int* arr;
}

// 질문 : sub3 함수는 몇 바이트 짜리 함수 인가요?
// arr(8바이트) + 배열공간(4 * 4 => 16바이트)
void sub3() {
    int arr[4];
}

// 질문 : arr1의 메모리 구조와 arr2의 메모리 구조를 비교해서 설명해주세요.
// 정답 
// - 초기값 여부
// - arr1 : 있음
// - arr2 : 없음
// - 초기값의 의미?
// - arr1 : 16평짜리 땅의 첫번째 방의 주소
// - arr2 : 없음
// - 값을 변경할 수 있는지 여부
// - arr1 : arr1 = arr2; 안된다x
// - arr2 : arr2 = arr1; 가능!
void sub4() {
    int arr1[4];
    int* arr2;
}

int main(void) {
    sub1();
    sub2();
    sub3();
    sub4();

    return 0;
}